use std::fmt::Write as _;
use std::io::Write as _;

use ts_bindgen::{TypeRegistry, TypeScriptDef, TypeScriptType};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut registry = TypeRegistry::default();

    client_sdk::models::gateway::message::ServerMsg::register(&mut registry);
    client_sdk::models::gateway::message::ClientMsg::register(&mut registry);

    client_sdk::api::error::ApiError::register(&mut registry);

    client_sdk::api::commands::register_routes(&mut registry);

    // generate TypeScript bindings, all of them

    let mut autogenerated = std::fs::File::create("out/autogenerated.ts")?;

    write!(autogenerated, "import type {{ ")?;

    for (idx, name) in registry.external().iter().enumerate() {
        if idx > 0 {
            write!(autogenerated, ", ")?;
        }

        write!(autogenerated, "{name}")?;
    }

    write!(
        autogenerated,
        " }} from './models';\nimport {{ command }} from './api/command';\n\n{}",
        registry.display()
    )?;

    //

    let models = std::fs::File::create("out/models.ts")?;
    let api = std::fs::File::create("out/api.ts")?;
    let gateway = std::fs::File::create("out/gateway.ts")?;

    let mut out = String::new();

    for (mut file, tag) in [(models, ""), (api, "command"), (gateway, "gateway")] {
        for group in ["decl", "values", "types"] {
            let tys = registry.iter().filter(|(name, _)| {
                if tag.is_empty() {
                    registry.type_tags(name).count() == 0
                } else {
                    registry.has_tag(name, tag)
                }
            });

            let mut idx = 0;

            for (name, ty) in tys {
                match group {
                    "decl" if matches!(ty, TypeScriptType::ApiDecl { .. }) => {}
                    "values" if ty.is_value() && !matches!(ty, TypeScriptType::ApiDecl { .. }) => {}
                    "types" if !ty.is_value() => {}
                    _ => continue,
                }

                if idx == 0 {
                    write!(out, "    {name}")?;
                } else if idx % 5 == 0 {
                    write!(out, ",\n    {name}")?;
                } else {
                    write!(out, ", {name}")?;
                }

                idx += 1;
            }

            if out.is_empty() {
                continue;
            }

            let comment = match group {
                "decl" => "API Command declarations",
                "values" => "Exported const values",
                "types" => "Exported types",
                _ => unreachable!(),
            };

            if group == "types" {
                writeln!(file, "/** {comment} */\nexport type {{")?;
            } else {
                writeln!(file, "/** {comment} */\nexport {{")?;
            }

            file.write_all(out.as_bytes())?;

            out.clear();

            write!(file, "\n}} from '../autogenerated';\n\n")?;
        }
    }

    Ok(())
}
